##### Android四大组件相关
Actvity:提供一个可以让用户操作的界面
Service：可以在后台长时间运行且没有用户界面的组件
BroadcastReceiver:一种广泛运用于在程序之间的传输信息机制
ContentProvider：内容提供，程序之间数据共享，可以把一个应用的数据给其他应用使用

Activity生命周期
- `onCreate` ，在第一次创建时调用。可做所有初始化操作，如创建视图，设置布局，绑定数据等，不可被杀死。
- `onRestart`，一般从不可见变为可见时调用，如返回桌面再回到app时，不可被杀死。
- `onStart`， 正在变为可见时调用，不可被杀死。
- `onResume`，可见状态，可与用户进行交互，处于栈顶，不可被杀死。
- `onPause`，暂停状态，此方法主要用于将未保存的状态进行持久化，停止动画等动作。此方法完成之后才会启动新的activity，可被杀死。
- `onStop`，停止状态，此方法应做一些重量级的回收工作，可被杀死。
- `onDestory`，销毁前调用，可被杀死。

Activity启动模式
1. standard,标准模式，每次启动新的activity都会创建新的实例，并将其压入栈顶
2. singleTop, 栈顶复用模式，如果启动的activity已经位于栈顶，那么不会重新创建
3. singleTask,栈内复用模式，如果启动的activity已经位于栈内，那么不会重新创建，并会将其调到栈顶，清除当前所有位于其之上的activity
4. singleInstance,加强版singleTask，此模式的activity只能单独存在于一个任务栈，后续请求均不会创建新的activity,除非这个任务栈被销毁

##### singleTop和singleTask被复用时，不会调用`onCreate`和`onStart`，但会回调`onNewIntent`方法
场景运用：
singleTop，假如一个客户端收到若干条推送，点击推送后进入详情页面，如果使用默认方式就会打开若干条详情页，不合理，应使用singleTop模式，这样就会复用一个详情页面。
singleTask，最常用的是app首页，因为首页一般长时间保存在栈中。

需要注意的地方：
1. 跳转到透明主题的activity时旧activity只会回调`onPause`，不会继续回调`onStop`.
2. 当旧activity的`onPause`方法完成之后才会执行新activity的`onCreate`.
3. 系统配置发生改变或者内存不足可能会导致activity被杀死，需要对当前activity做缓存处理，回调`onSaveInstanceState`方法，将数据保存在Bundle中，在activity重新创建之后`onCreate`和`onRestoreInstanceState`方法会收到Bundle中保存的数据。注意两者的区别，`onCreate`中接收Bundle必须进行空判断，而`onRestoreInstanceState`一旦被调用Bundle肯定是有值的。
4. 由于`onSaveInstanceState`的不确定性，只可以在此方法中记录activity的瞬间状态，数据持久化应在`onPause`中。

##### 一个程序有几个Context?
context数量 = activity数量 + service数量 + 1

Service生命周期
startService:
onCreate->onStartCommand->onDestroy
bindService:
onCreate->onBind()->onUnbind->onDestroy

##### 两种启动方式的区别？
- context中通过bindService方法来进行service与context的关联并启动，并且service的生命周期依附于context
- 通过startService方式启动service的生命周期与启动它的context无关

##### 如何保证Service不被杀死？
1. 在onDestry里启动Service
2. 监听系统广播，如果还能监听到广播就说明服务没有被杀死
3. 提升优先级： android:priority="1000"

BradcastReceiver
使用场景：
1. 同一个app具有多个进程的不同组件之间消息通信
2. 不同app之间的组件之间消息通信
种类：
1. 普通广播
2. 有序广播
3. 本地广播。只在app内传播
实现方式：
1. 静态注册，在AndroidManifest文件中使用<receiver>注册，此方法注册后会一直运行。
2. 动态注册，跟随activity生命周期，调用`registerReceiver`，会随着activity的销毁而销毁
LocalBroadcastReceiver
1. 只在app内传播，不用担心数据泄露
2. 比系统的全局广播更加高效，主要原因是内部使用Handler实现，它的sendBroadcast方法其实是通过handler发送一个message

ContentProvider
应用程序间数据共享的组件，通过uri的形式将数据向外发送