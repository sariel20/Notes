##### Android四大组件相关
Actvity:提供一个可以让用户操作的界面
Service：可以在后台长时间运行且没有用户界面的组件
BroadcastReceiver:一种广泛运用于在程序之间的传输信息机制
ContentProvider：内容提供，程序之间数据共享，可以把一个应用的数据给其他应用使用

Activity生命周期
- `onCreate` ，在第一次创建时调用。可做所有初始化操作，如创建视图，设置布局，绑定数据等，不可被杀死。
- `onRestart`，一般从不可见变为可见时调用，如返回桌面再回到app时，不可被杀死。
- `onStart`， 正在变为可见时调用，不可被杀死。
- `onResume`，可见状态，可与用户进行交互，处于栈顶，不可被杀死。
- `onPause`，暂停状态，此方法主要用于将未保存的状态进行持久化，停止动画等动作。此方法完成之后才会启动新的activity，可被杀死。
- `onStop`，停止状态，此方法应做一些重量级的回收工作，可被杀死。
- `onDestory`，销毁前调用，可被杀死。

Activity启动模式
1. standard,标准模式，每次启动新的activity都会创建新的实例，并将其压入栈顶
2. singleTop, 栈顶复用模式，如果启动的activity已经位于栈顶，那么不会重新创建
3. singleTask,栈内复用模式，如果启动的activity已经位于栈内，那么不会重新创建，并会将其调到栈顶，清除当前所有位于其之上的activity
4. singleInstance,加强版singleTask，此模式的activity只能单独存在于一个任务栈，后续请求均不会创建新的activity,除非这个任务栈被销毁

##### singleTop和singleTask被复用时，不会调用`onCreate`和`onStart`，但会回调`onNewIntent`方法
场景运用：
singleTop，假如一个客户端收到若干条推送，点击推送后进入详情页面，如果使用默认方式就会打开若干条详情页，不合理，应使用singleTop模式，这样就会复用一个详情页面。
singleTask，最常用的是app首页，因为首页一般长时间保存在栈中。

需要注意的地方：
1. 跳转到透明主题的activity时旧activity只会回调`onPause`，不会继续回调`onStop`.
2. 当旧activity的`onPause`方法完成之后才会执行新activity的`onCreate`.
3. 系统配置发生改变或者内存不足可能会导致activity被杀死，需要对当前activity做缓存处理，回调`onSaveInstanceState`方法，将数据保存在Bundle中，在activity重新创建之后`onCreate`和`onRestoreInstanceState`方法会收到Bundle中保存的数据。注意两者的区别，`onCreate`中接收Bundle必须进行空判断，而`onRestoreInstanceState`一旦被调用Bundle肯定是有值的。
4. 由于`onSaveInstanceState`的不确定性，只可以在此方法中记录activity的瞬间状态，数据持久化应在`onPause`中。

##### 一个程序有几个Context?
context数量 = activity数量 + service数量 + 1

##### 什么是Context?
1. 他描述的是一个应用程序环境信息，即上下文
2. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如启动activity，发送广播，接收intent等。

Service生命周期
startService:
onCreate->onStartCommand->onDestroy
bindService:
onCreate->onBind()->onUnbind->onDestroy

##### 两种启动方式的区别？
- context中通过bindService方法来进行service与context的关联并启动，并且service的生命周期依附于context
- 通过startService方式启动service的生命周期与启动它的context无关

##### 如何保证Service不被杀死？
1. 在onDestry里启动Service
2. 监听系统广播，如果还能监听到广播就说明服务没有被杀死
3. 提升优先级： android:priority="1000"

BradcastReceiver
##### 广播内禁止耗时操作，不允许开启子线程
使用场景：
1. 同一个app具有多个进程的不同组件之间消息通信
2. 不同app之间的组件之间消息通信
种类：
1. 普通广播
2. 有序广播
3. 本地广播。只在app内传播
实现方式：
1. 静态注册，在AndroidManifest文件中使用<receiver>注册，此方法注册后会一直运行。
2. 动态注册，跟随activity生命周期，调用`registerReceiver`，会随着activity的销毁而销毁
LocalBroadcastReceiver
1. 只在app内传播，不用担心数据泄露
2. 比系统的全局广播更加高效，主要原因是内部使用Handler实现，它的sendBroadcast方法其实是通过handler发送一个message

ContentProvider
应用程序间数据共享的组件，通过uri的形式将数据向外发送

##### 什么是ANR？如何避免？
app有一段时间相应不够灵敏，系统会向用户弹出一个对话框，称作应用程序无响应。发生时间：主线程（activity,service）五秒，BroadCastReceiver十秒
解决办法：将所有耗时操作如访问网络，数据库读取等任务放入子线程，通过handler等方式更新ui

---------------------------
##### 多线程，消息机制相关
1. 什么是Handler?
Handler是官方给我们提供的一套更新UI的机制，也是一套消息处理机制，可以通过Handler来处理消息，更新UI等。
2. Handler机制是什么？
首先Handler发送一个消息在MessageQueue里面，然后通过Looper的loop方法进行无限循环，如果产生了一条新的消息，那么就调用Handler的handlerMessage方法进行余下操作。
3. 只能在UI线程更新界面吗？
不一定。Android在线程立面采用checkThread进行判断是否是主线程，而这个方法是在onResume调用的，因此如果这个时候子线程在onCreate方法里面更新ui也是可以的。
4. 子线程更新ui的方式？
- 采用Handler的方式
- View的post方法
- runOnUIThread
5. 什么是HandlerThread？
异步处理机制，为了避免线程切换导致空指针异常。
6. ThreadLocal工作原理
ThreadLocal是一个线程内部数据存储类，Looper,ActivityThread以及AMS都用到了ThreadLocal，当某些数据是以线程为作用域并且不同线程具有不同副本时考虑使用。

##### 网络编程
1. 什么是Socket?
网络上两个程序通过一个双向的通讯连接实现数据交换，这个双向链路的一端称为一个Socket。
2. Socket通讯过程
Server端监听某一个端口是否有连接请求，客户端向服务端发出连接请求，服务端向客户端返回接受消息，一个Socket就建立起来了。

##### View绘制流程
三大流程均是通过ViewRoot完成。
1. onMeasure
测量过程，测量视图大小，从顶层父View到子View地鬼调用measure方法
2. onLayout
布局过程，确定视图位置，进行页面布局，父view根据measure子view所得到的布局大小和布局参数将子view放在合适的位置上
3. onDraw 
绘制过程，将视图绘制出来

##### 自定义View
1. 自定义view步骤？
- 自定义view的属性，在values/attrs.xml里面定义，然后再layout中使用，通过context.obtainStyledAttributes(attrs,R.styleable.自定义名字)获取
- 进行测量onMeasure
- 如果是ViewGroup还需要设置子view的位置，一般通过requestLayout触发onLayout方法
- 在onDraw通过Canvas的一些方法进行绘制
- 如果需要触摸事件的话，需回调onTouchEvent
2. 自定义view需要注意些什么？
- 需要让view支持wrap_content
直接继承view如果不在onMeause中对wrap_content进行特殊处理，那么当外界布局使用wrap_content就无法达到预期效果
- 有必要的话让view支持padding属性
直接继承view如果不在draw中处理padding，那么padding属性就不会起作用
- 尽量不要在view中使用handler，因为view本身提供post方法可替代handler
- view中如果有线程或者动画需要及时停止
- view带有滑动嵌套需要处理好滑动冲突问题