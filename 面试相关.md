##### Android四大组件相关
Actvity:提供一个可以让用户操作的界面
Service：可以在后台长时间运行且没有用户界面的组件
BroadcastReceiver:一种广泛运用于在程序之间的传输信息机制
ContentProvider：内容提供，程序之间数据共享，可以把一个应用的数据给其他应用使用

Activity生命周期
- `onCreate` ，在第一次创建时调用。可做所有初始化操作，如创建视图，设置布局，绑定数据等，不可被杀死。
- `onRestart`，一般从不可见变为可见时调用，如返回桌面再回到app时，不可被杀死。
- `onStart`， 正在变为可见时调用，不可被杀死。
- `onResume`，可见状态，可与用户进行交互，处于栈顶，不可被杀死。
- `onPause`，暂停状态，此方法主要用于将未保存的状态进行持久化，停止动画等动作。此方法完成之后才会启动新的activity，可被杀死。
- `onStop`，停止状态，此方法应做一些重量级的回收工作，可被杀死。
- `onDestory`，销毁前调用，可被杀死。

Activity启动模式
1. standard,标准模式，每次启动新的activity都会创建新的实例，并将其压入栈顶
2. singleTop, 栈顶复用模式，如果启动的activity已经位于栈顶，那么不会重新创建
3. singleTask,栈内复用模式，如果启动的activity已经位于栈内，那么不会重新创建，并会将其调到栈顶，清除当前所有位于其之上的activity
4. singleInstance,加强版singleTask，此模式的activity只能单独存在于一个任务栈，后续请求均不会创建新的activity,除非这个任务栈被销毁

##### singleTop和singleTask被复用时，不会调用`onCreate`和`onStart`，但会回调`onNewIntent`方法
场景运用：
singleTop，假如一个客户端收到若干条推送，点击推送后进入详情页面，如果使用默认方式就会打开若干条详情页，不合理，应使用singleTop模式，这样就会复用一个详情页面。
singleTask，最常用的是app首页，因为首页一般长时间保存在栈中。

需要注意的地方：
1. 跳转到透明主题的activity时旧activity只会回调`onPause`，不会继续回调`onStop`.
2. 当旧activity的`onPause`方法完成之后才会执行新activity的`onCreate`.
3. 系统配置发生改变或者内存不足可能会导致activity被杀死，需要对当前activity做缓存处理，回调`onSaveInstanceState`方法，将数据保存在Bundle中，在activity重新创建之后`onCreate`和`onRestoreInstanceState`方法会收到Bundle中保存的数据。注意两者的区别，`onCreate`中接收Bundle必须进行空判断，而`onRestoreInstanceState`一旦被调用Bundle肯定是有值的。
4. 由于`onSaveInstanceState`的不确定性，只可以在此方法中记录activity的瞬间状态，数据持久化应在`onPause`中。

##### 一个程序有几个Context?
context数量 = activity数量 + service数量 + 1

##### 什么是Context?
1. 他描述的是一个应用程序环境信息，即上下文
2. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如启动activity，发送广播，接收intent等。

Service生命周期
startService:
onCreate->onStartCommand->onDestroy
bindService:
onCreate->onBind()->onUnbind->onDestroy

##### 两种启动方式的区别？
- context中通过bindService方法来进行service与context的关联并启动，并且service的生命周期依附于context
- 通过startService方式启动service的生命周期与启动它的context无关

##### 如何保证Service不被杀死？
1. 在onDestry里启动Service
2. 监听系统广播，如果还能监听到广播就说明服务没有被杀死
3. 提升优先级： android:priority="1000"

BradcastReceiver
##### 广播内禁止耗时操作，不允许开启子线程
使用场景：
1. 同一个app具有多个进程的不同组件之间消息通信
2. 不同app之间的组件之间消息通信
种类：
1. 普通广播
2. 有序广播
3. 本地广播。只在app内传播
实现方式：
1. 静态注册，在AndroidManifest文件中使用<receiver>注册，此方法注册后会一直运行。
2. 动态注册，跟随activity生命周期，调用`registerReceiver`，会随着activity的销毁而销毁
LocalBroadcastReceiver
1. 只在app内传播，不用担心数据泄露
2. 比系统的全局广播更加高效，主要原因是内部使用Handler实现，它的sendBroadcast方法其实是通过handler发送一个message

ContentProvider
应用程序间数据共享的组件，通过uri的形式将数据向外发送

##### 什么是ANR？如何避免？
app有一段时间相应不够灵敏，系统会向用户弹出一个对话框，称作应用程序无响应。发生时间：主线程（activity,service）五秒，BroadCastReceiver十秒
解决办法：将所有耗时操作如访问网络，数据库读取等任务放入子线程，通过handler等方式更新ui

---------------------------
##### 多线程，消息机制相关
1. 什么是Handler?
Handler是官方给我们提供的一套更新UI的机制，也是一套消息处理机制，可以通过Handler来处理消息，更新UI等。
2. Handler机制是什么？
首先Handler发送一个消息在MessageQueue里面，然后通过Looper的loop方法进行无限循环，如果产生了一条新的消息，那么就调用Handler的handlerMessage方法进行余下操作。
3. 只能在UI线程更新界面吗？
不一定。Android在线程立面采用checkThread进行判断是否是主线程，而这个方法是在onResume调用的，因此如果这个时候子线程在onCreate方法里面更新ui也是可以的。
4. 子线程更新ui的方式？
- 采用Handler的方式
- View的post方法
- runOnUIThread
5. 什么是HandlerThread？
异步处理机制，为了避免线程切换导致空指针异常。
6. ThreadLocal工作原理
ThreadLocal是一个线程内部数据存储类，Looper,ActivityThread以及AMS都用到了ThreadLocal，当某些数据是以线程为作用域并且不同线程具有不同副本时考虑使用。
7. Handler使用方式
- mHandler.post(runnable)
- mHandler.sendMessage(msg)
8. 什么是AsyncTask?
本质上就是封装了线程池和handler的异步框架
9. AsyncTask使用方法？
- 三个参数
params 在执行AsyncTask时所需要传入的参数，可用于在后台任务中使用。
progress 后台任务执行时，如果需要在界面上显示进度，则使用这里指定的泛型作为进度单位。
result 当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。
- 四个方法
onPreExecute() 在后台任务执行前调用，用于一些初始化操作，比如显示一个进度框
doInBackground(Integer... params) 在这里处理耗时任务，任务一旦完成就通过return将任务的执行结果返回。这个方法内不可更新UI，可调用publishProgress()方法反馈当前任务执行的进度
onProgressUpdate(Integer... values) 当在后台任务中调用了publishProgress()方法后，就会很快的调用这个方法，该方法中携带的参数就是在后台任务中传递过来的，这里可以进行UI操作，比如更新进度条
onPostExecute(String result) 当后台任务执行完毕并通过return语句返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中。

---------------------------
##### 网络编程
1. 什么是Socket?
网络上两个程序通过一个双向的通讯连接实现数据交换，这个双向链路的一端称为一个Socket。
2. Socket通讯过程
Server端监听某一个端口是否有连接请求，客户端向服务端发出连接请求，服务端向客户端返回接受消息，一个Socket就建立起来了。

---------------------------
##### View绘制流程
三大流程均是通过ViewRoot完成。
1. onMeasure
测量过程，测量视图大小，从顶层父View到子View地鬼调用measure方法
2. onLayout
布局过程，确定视图位置，进行页面布局，父view根据measure子view所得到的布局大小和布局参数将子view放在合适的位置上
3. onDraw 
绘制过程，将视图绘制出来

---------------------------
##### 自定义View
1. 自定义view步骤？
- 自定义view的属性，在values/attrs.xml里面定义，然后再layout中使用，通过context.obtainStyledAttributes(attrs,R.styleable.自定义名字)获取
- 进行测量onMeasure
- 如果是ViewGroup还需要设置子view的位置，一般通过requestLayout触发onLayout方法
- 在onDraw通过Canvas的一些方法进行绘制
- 如果需要触摸事件的话，需回调onTouchEvent
2. 自定义view需要注意些什么？
- 需要让view支持wrap_content
直接继承view如果不在onMeause中对wrap_content进行特殊处理，那么当外界布局使用wrap_content就无法达到预期效果
- 有必要的话让view支持padding属性
直接继承view如果不在draw中处理padding，那么padding属性就不会起作用
- 尽量不要在view中使用handler，因为view本身提供post方法可替代handler
- view中如果有线程或者动画需要及时停止
- view带有滑动嵌套需要处理好滑动冲突问题

---------------------------
##### 事件分发机制
Activity -> PhoneWindow -> DecorView -> ViewGroup -> View
1. 为什么会有事件分发机制？
android上面的view是树形结构，view可能会重叠在一起，当我们点击的地方有多个view可以响应的时候，就用到了事件分发机制。
2. 三个重要的事件分发方法
- dispatchTouchEvent
用来实现事件分发，判断onInterceptTouchEvent是否拦截此事件
- onInterceptTouchEvent
判断是否拦截某个事件
- onTouchEvent
处理点击事件
3. 怎么拦截事件？
ViewGroup通过onInterceptTouchEvent方法拦截
返回true拦截事件，不再向下传递
返回false不拦截时间，继续向下传递

---------------------------
##### Android数据存储形式
1. Sqlite
轻量级数据，支持基本sql语法，android提供sqlteDatabase封装操作数据库的api
2. sharedPreference
xml文件存储方式
3. File
文件io存储方式，不推荐这种方式，更新困难
4. ContentProvider
android中可以实现数据共享的存储方式，由于数据通常相对私密，使用此方式持久化较少

---------------------------
##### json
1. 什么是json？优缺点是什么？
json是存储和交换文本信息的语法，比xml更小，更快，更易解析
优点：
数据格式比较简单，易于读写，支持多种语言，解析简单
缺点：
相对xml来说对数据的描述性更差
2. 如何解析json?
andorid有两种常用方式
- 原生技术
特点：麻烦，对于复杂的json数据容易出错
	
	JSONObject jsonObject = new JSONObject(json);
	int id = jsonObject.optInt("id");
	String name = jsonObject.optString("name");
	...
	//json数组解析
	JSONArray jsonArray = new JSONArray(json);
	for(...i<jsonArray.length()..){
		JSONObject jo = jsonArray.getJSONObject(i);
		......
	}

- Gson框架
特点：解析简单，代码量少，很方便的解析复杂的json数据

	Gson gson = new Gson();
	Info info = gson.fromJson(jsonStr,Info.class);
	...
	//解析json数组
	Gson g = new Gson();
	List<Info> info = gson.fromJson(jsonStr,new TypeToken<List<Info>>(){}.getType());
	....

---------------------------
##### 设计模式
1. 单例模式
Android中的应用：
Application
定义：
保证一个类仅有一个实例，并提供一个访问他的全局访问点
概念：
是一种对象的创建模式，用于产生一个对象的具体实例，可以确保系统中一个类只产生一个实例
好处：
对于频繁使用的对象可以省略创建所花费的时间，这对于那些重量级对象而言，是非常客观的系统开销
由于new操作的次数减少，因而对系统内存的使用概率也会降低
种类：
懒汉，饿汉，DCL，静态内部类，枚举
推荐写法：
静态内部类
优点：
保证线程安全
利用静态变量的唯一性
2. 观察者模式
Android中的应用:
Adapter.notifyDataChanged()
概念：
定义对象之间一对多的依赖关系，使得每当一个对象状态发生改变的时候，其相关依赖对象皆得到通知并自动更新
使用场景:
一个抽象模型有两个分方面，一个方面依赖于另一个方面
一个对象的改变将导致一个或多个其他对象也发生改变
需要在系统中创建一个触发链，A影响B影响C
3. 适配器模式
Android中的应用：
所有的Adapter
定义：
将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
功能：
进行转换匹配，目的是复用已有的功能，而不是来实现新的接口
优点：
更好的复用性和扩展性

---------------------------
##### MVC,MVP,MVVM
- MVP
视图View,控制器Presenter,模型Model
各部分之间的通信都是双向的
View和Model不发生联系，都通过Presenter联系
View不部署任何业务逻辑，所有业务逻辑都部署在Presenter

- MVC
视图View,控制器Controller,模型Model
通信方式：
View传送指令到Controller
Controller完成业务逻辑后，要求Model改变状态
Model将新的数据发送到View，用户得到反馈

- MVVM
类似MVP，将Presenter改为ViewModel

---------------------------
##### 第三方框架
1. Retrofit
使用流程：
首先创建一个Retrofit对象，指定api域名
其次根据api新建一个java接口，用注解描述这个api
再用这个retrofit对象创建一个Api对象
最后使用Call对象获取数据

2. Picasso
3. glide
4. EventBus
5. Dagger2



---------------------------
##### 小知识点
- res/raw和assets的不同点
res/raw会被映射到R文件中，访问的时候直接使用资源id；assets文件夹下的文件不会被映射到r文件中，访问时需要AssetManager类
res/raw不可以有目录结构，assets可以

- 动画有哪几类，特点和区别
补间动画和帧动画
补间动画通过指定view的开始结束状态和变化时间，方式，对view的内容完成一系列的图形变换来实现动画效果
帧动画就是指定每一帧的内容和停留时间，然后播放动画

- 长连接，心跳机制
心跳机制是定时发送一个自定义结构体包，让对方知道自己还活着，以确保连接的有效性机制

- 三级缓存
内存缓存，本地缓存，网络加载
内存缓存优先，本地次优先，网络最后
