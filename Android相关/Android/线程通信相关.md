#### Google明确声明多线程编程的两大原则  
1.不要阻塞UI线程
2.不要在UI线程之外访问UI组件

为了避免在UI线程即主线程中处理耗时任务(避免阻塞线程)，需要将耗时任务抛到工作线程中，处理任务后再将任务抛给主线程更新UI.

	
	private void onCreate(Bundle){
		.....
	
		mRunnable = new Runnable(){
		public void run(){
			Thread.sleep(1000);
			//在非UI线程中访问UI组件
			tv.setText("Task Done!!");
			｝
		｝;
		btn.setOnClickListener(new OnClickLintener(){
			Thread thread = new Thread(mRunnable);
			thread.start();
		});	
	}
上面的代码定义了一个Button和TextView，如果点击Button就会开启一个新线程执行耗时任务，但上面的代码点击后会崩溃，因为在非UI线程之外访问UI组件了。
##### 以下五种方法解决上面的问题
1. Handler.sendMessage()等方法
在工作线程中
tv.setText("")
改为 `mHandler.sendEmptyMessage(0x123);`
在activity中定义一个Handler
`Handler mHandler = new Handler(){  
        ....handleMessage(Message msg){  
            if(msg.what == 0x123){ text.setText("Task Done!!");}}};  `

2. Handler.post(Runnable)
将代码
`tv.setText("")`
改为
`mHandler.post(new Runnable(){
	..run(){tv.setText();}})`

3. Activity.runOnUIThread(Runnable)
将代码改为
`runOnUiThread(new Runnable(){
...run(){tv.setText()}})`

4. View.post(Runnable)
将代码改为
`tv.post(new Runnable(){
...run(){tv.setText()}})`

5. AsyncTask
新建AsyncTask类，在doInBackground方法中执行耗时任务，具体在单独笔记中记录学习。

#### Handler消息机制
Handler的运行需要底层的MessageQueue和Looper支撑
_Looper_ 内部包含一个消息队列，也就是MessageQueue，所有Handler发送的消息都走向消息队列`.loop`方法，该方法不断的从MessageQueue中获取消息

** Handler负责发送消息，Looper负责接受Handler发送的消息，并直接把消息传给Handler自己，MessageQueue就是一个存储消息的容器 **

#### Looper
Looper使普通线程变为循环线程
`Looper.prepare();`将当前线程初始化为looper线程
`Looper.loop()` 开始循环处理消息队列
__一个线程中只能存在一个looper对象__

![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/looper.png)  

`Looper.prepare()`
每个线程中的looper对象其实是一个ThreadLocal，即本地存储对象
ThreadLocal的作用是在每个线程中存储数据
可以再不同的线程中互不干扰的存储或者提供火速局
通过ThreadLoacl可以获取每个线程中的Looper

`Looper.loop()`
调用此方法后线程开始工作
不断的从MessageQueue中取出消息
![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/loop.png)  

`Looper.myLooper()`得到当前线程的looper对象
`Looper.getThread()`得到Looper对象所属线程
`Looper.quit()`结束循环

#### Handler
通知MessageQueue要执行一个任务(sendMessage),并在loop自己的时候执行该任务(handlerMessage)，整个过程是异步的
handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的
![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/handler.png)  
一个线程中可以有多个handler，但只能有一个looper

##### 消息处理
通过核心方法`dispatchMessage(msg)`与`handlerMessage(msg)`完成Handler可以在任意线程发送消息，这些消息会被添加到关联的MessageQueue上
![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/MessageQueue.png)  
![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/looper2.png)  

##### Android主线程也是一个Looper线程
![enter image description here](https://github.com/sariel20/StudyNotes/blob/master/Android%E7%9B%B8%E5%85%B3/img/MainThread.png)  

##### HandlerThread 解决多线程并发问题
HandlerThread继承Thread，线程运行后同时创建含有消息队列的Looper，并对外提供自己的Looper对象get方法
优点
- 开发中如果多次使用`new Thread` 这种方法开启子线程会创建多个匿名线程，导致程序变慢，使用HandlerThread自带的looper可以通过消息来多次重复使用当前线程，节省开支
- 对于非UI线程又想使用消息机制，用HandlerThread内部的Looper是最合适的，不会干扰或阻塞UI线程

		handlerThread = new HandlerThread("thread");
		handlerThread.start();
		workHandler = new WorkHandler(handlerThread.getLooper());
